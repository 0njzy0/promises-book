[[beginning-story]]
== 書籍の始まり

この書籍を書くことにしたのは、私自身が運営する JSer.info にて、
http://jser.info/post/77696682011/es6-promises[あなたが読むべきJavaScript Promises | JSer.info] という記事を書いた事が始まりの一つです。

この記事を書く際にECMAScript6 Promisesについて色々調べながら書いていましたが、
最終的に扱いきれてない情報もありました。

- https://github.com/azu/jser.info/pull/17[あなたが読むべきPromises by azu · Pull Request #17 · azu/jser.info]

またこの時、電子書籍はどのようなワークフローで書かれているんだろう？ということに興味を持っていて、
それを学ぶには実際に電子書籍を書いてみるのが早いと思ったのも書き始めた理由の一つです。

一番最初に自分用の今後やりたいTodoを書いているリポジトリにIssueを立てることから始めました。

- https://github.com/azu/azu/issues/7[Promisesの薄い本 · Issue #7 · azu/azu]

電子書籍を書くにはどのフォーマットで書くのかを決めなければなりません。

以前、 http://the-little-book-of-busterjs.readthedocs.org/en/latest/[The little book of Buster.JS] という電子書籍を書いた際は、
Sphinx(reStructuredText)を使って書いていたため、今回は別の方法を取ってみようと考えました。

最初に候補にしたのは人気のあるMarkdownでした。
しかし、Markdownには外部ファイルを読み込んで埋め込む標準的な方法がありません。

The little book of Buster.JS を書いた時からサンプルコードにテストを書くことにしていたので、
外部ファイルを読み込む機能は必要なものでした。

拡張したMarkdownフォーマットを利用するのも良いですが、その時にAsciiDocというOreillyも使っているフォーマットがあることを思い出しました。
また、Asciidocのモダンな処理エンジンとして http://asciidoctor.org/[Asciidoctor] という実装があることを知り、
これを使ってみようと思い書き始めました。

つまり、主目的は電子書籍を書いてみたいという欲求で、サブ目的がES6 Promisesについて扱いきれなかったものを書く
というのがこの書籍を書き始めた理由です。

== 書き始めのワークフロー

おおまかに書く内容と形式を決めましたが、
私は形から入るタイプなので、Asciidocで書くときにどのようなプロジェクト構造が良いのか悩んでいた記憶があります。

そのため、一番最初に書いたのは https://github.com/azu/promises-book/commit/bbf23086c5bbaf60bd9991b5b1a4229ce54dfb30[CONTRIBUTE.md] で、
コントリビュートガイドを書くという形でプロジェクトの構造がどうあるべきかについて決めていきました。

書籍の内容としては、Promiseの基本的な使い方、パターンをコード例中心に書いていくというおおまかな方針が決まっていたので、
それをより明確にするためにアウトラインを軽く固めていきました。

- https://github.com/azu/promises-book/pull/1[この書籍で扱う内容について by azu · Pull Request #1 · azu/promises-book]

アウトラインを固めていきつつ、書籍を書く上で一番コワかったのが**飽きること**だったので、
とりあえずでもいいから気になったことについてをセクションに分けて書いていきました。

そのため、書いた順番はかなりバラバラで、第二章や第四章を最初の頃に書いていました。

多くのセクションは、最初にコンセプトなるサンプルコードとテストを書いて、
それに対する解説して文章を書いていくという方針で行っていたものが多かったと記憶しています。

そのため、いいサンプルコードが思いつかないセクションは後回しにしていました。

== 移動中に書く

飽きる前に一度完成の形まで持って行きたいという気持ちがあったため、
とりあえずの目標として三ヶ月でひとまずの完成まで持っていくとしていました。

この書籍以外にもやりたいことは山ほどあるので、
どう目標を達成するか考える前に、空いてる時間を使っていくしかないという感じがしてました。

空いてる時間として一番ありそうなのは移動中の時間でした。

MacBook Proの上にThinkPad Bluetooth keyboardを載せて使えば、
普段とあまり変わらないレベルで書けることがわかったので、移動中にコーディングや文章を書き進めていきました。

もちろん、この文章も移動中に書いてます。

移動中に書く短所としては、電波があまり強くないのでオフライン環境になってしまうケースがあることでした。
そのため、移動する前に移動中に何を書くのかを計画してから進める癖が自然とついた気がします。

その影響はGithub Issueの使い方に強く出ていたと思います。

実際にセクションを書く前に、Github Issueにそれぞれのセクションでやりたいことや、
コンセプトとなるサンプルコードのアイデアを大量にメモるようにしていました。

メモやアイデアを元に、移動中に実装などを進めることで結構集中してできたと思います。
それぞれのセクションはGitのブランチを切って進めて、`[WIP]`のpull-requestを出した状態で進めていました。

`WIP`のpull-requestを作って置くことで、
そのIssueに対してどこまでやったのかや、別のアイデアが思いついた時は書くことできるため、
書いてる文章やコードに対する意見等も記録して残しやすくなりました。

一度の移動中でセクションが完成することは少ないので、
どこまでやったかが簡単に見られるようにすることは結構大事でした。

2014年3月2日に書き始めて、2014年6月2日に全ての章が書き終わり、リファクタリングに入ったので、
大体目標を達成できたように思えます。

== Github Issueを使ったワークフローの変遷

先ほども書いたように、WIP pull-requestを使ったワークフローを取っていましたが、
最初からそのワークフローで書いていた訳ではありません。

最初の頃はGithub Issueにアイデアをメモるだけで、殆どmasterブランチで作業していましたが、
第四章の応用の内容を書いていくあたりからワークフローが変わってきました。

この書籍の第四章では、第二章の基礎を発展させた応用的な使い方について書いています。
しかし、それまで好き勝手書いていたため、応用するにも基礎の部分の説明をまだ書いてないというセクションがでてきました。

セクション毎にIssueは立てていたので、どのIssue同士が関係あるのかをIssue References(Issue番号書くだけ)
で整理したり、文章全体としての流れを汲み取っていく必要が出てきました。

大抵は一つのセクションが一つのIssueと対応していたので、
作業も一つのセクションと一つのpull-requestを対応させてやって方が管理しやすいと気付きました。

これが自分自身にWIP pull-requestをするようになった理由だと思います。

[NOTE]
Github Issueを使った執筆のワークフローについては
http://azu.github.io/slide/udonjs/github-issue.html[一人で使えるGithub Issue] にまとめています。

