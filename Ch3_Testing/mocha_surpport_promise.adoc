== MochaのPromisesサポート

MochaがサポートしてるPromiseのテストとは何かについて学んでいきましょう。

公式サイトの http://visionmedia.github.io/mocha/#asynchronous-code[Asynchronous code]にもその概要が書かれています。

> Alternately, instead of using the done() callback, you can return a promise. This is useful if the APIs you are testing return promises instead of taking callbacks:

Promiseのテストの場合は`done()`の代わりに、promiseオブジェクトをreturnすることでできると書いてあります。

実際にどういう風に書くかの例を見て行きたいと思います。

[source,js]
.mocha-promise-test.js
----
include::test/mocha-promise-test.js[]
----

<<promise-assert-fail-fixed,先ほどの`done`を使った例>>をMochaのPromiseテストの形式に変更しました。

変更点としては以下の2箇所です

* `done` そのものを取り除いた
* テストしたい`assert`が登録されてるpromiseオブジェクトを返すようにした

この書き方をした場合は、`assert`が失敗した場合はもちろんテストが失敗します。

[source,js]
----
it("should be fail", function () {
    return Promise.resolve().then(function () {
        assert(false);// => テストが失敗する
    });
});
----

これにより`.then(done, done);`というような本質的にはテストに関係ない記述を省くことが出来るようになりました。

[[INFO]]
====
http://efcl.info/2014/0314/res3708/[MochaがPromisesのテストをサポートしました | Web scratch] という記事でも
MochaのPromiseサポートについて書かれています。
====

=== `catch`によるテスト

MochaがPromiseのテストをサポートしているため、これでよいと思われるかもしれませんが、
この書き方にも意図しない結果になる例外が存在します。

例えば、以下はある条件だとrejectされるコードがあり、
そのエラーメッセージをテストしたいという目的のコードを簡略化したものです。

このテストの目的

`mayBeRejected()`がresolveした場合::
    テストを失敗させる
`mayBeRejected()`がrejectした場合::
    `assert`でErrorオブジェクトをチェックする

[source,js]
[[mocha-rejected-promise-test]]
----
function mayBeRejected(){ // <1>
    return Promise.reject(new Error("woo"));
}
it("is bad pattern", function () {
    return mayBeRejected().catch(function (error) {
        assert(error.message === "woo");
    });
});
----
<1> この関数が返すpromiseオブジェクトをテストしたい

この場合は、`Promise.reject`は`onRejected`に登録された関数を呼ぶため、
テストはパスしますね。

このテストで問題になるのは`mayBeRejected()`で返されたpromiseオブジェクトが
**resolveされた場合**に、必ずテストがパスしてしまうという問題が発生します。

[source,js]
----
function mayBeRejected(){ // <1>
    return Promise.resolve();
}
it("is bad pattern", function () {
    return mayBeRejected().catch(function (error) {
        assert(error.message === "woo");
    });
});
----
<1> 返されるpromiseオブジェクトはresolveする

この場合、`catch`で登録した`onRejected`の関数はそもそも呼ばれないため、
`assert`がひとつも呼ばれることなくテストが必ずパスしてしまいます。

これを解消しようとして、`.catch`の前に`.then`を入れて、
`.then`が呼ばれたらテストを失敗にしたいと考えるかもしれません。

[source,js]
----
function throwError(value) { // <1>
    throw new Error(value);
}
function mayBeRejected(){
    return Promise.resolve();
}
it("should bad pattern", function () {
    return mayBeRejected().then(throwError).catch(function (error) {
        assert.deepEqual(error.message === "woo");
    });
});
----
<1> throwすることでテストを失敗にしたい

しかし、この書き方だと<<then-or-catch,then or catch?>>で紹介したように、
`throwError`で投げられたエラーが`catch`されてしまいます。

.Then Catch flow
image::../Ch2_HowToWrite/img/then_catch.png[Then Catch flow]

`then` -> `catch` となり、`catch`に渡ってくるErrorオブジェクトは`AssertionError`となり、
意図したものとは違うものが渡ってきてしまいます。

=== `catch`によるテストの改善

<<mocha-rejected-promise-test,上記のエラーをテスト>>したい場合は、どうすればよいでしょうか?

先ほどとは逆に `catch` -> `then` とした場合は、以下のように意図した挙動になります。

resolveした場合::
    意図した通りテストが失敗する
rejectした場合::
    `assert`でテストを行える

[source,js]
----
function mayBeRejected() {
    return Promise.resolve();
}
it("catch -> then", function () {
    return mayBeRejected().catch(function (error) {
        assert(error.message === "woo");
    }).then(throwError);// <1>
});
----
<1> resolveされた場合はテストは失敗する

このコードをよく見てみると、`.then(onFulfilled, onRejected)` の一つにまとめられることに気付きます。

[source,js]
----
function mayBeRejected() {
    return Promise.resolve();
}
it("catch -> then", function () {
    return mayBeRejected().then(throwError, function (error) {
        assert(error.message === "woo");
    });
});
----

<<then-or-catch,then or catch?>>の時は、エラーの見逃しを避けるため、
`.then(onFulfilled, onRejected)`の第二引数ではなく、`then` -> `catch`と分けることを推奨していました。

しかし、テストの場合はPromiseの強力なエラーハンドリングが逆にテストの邪魔をしてしまいます。
そのため`.then(onFulfilled, onRejected)`というように指定すると、より簡潔にテストを書くことが出来ます。

=== まとめ

* 通常のコードは`then` -> `catch`と分けた方がよい
** エラーハンドリングのため。<<then-or-catch,then or catch?>>を参照
* テストコードは`then`にまとめた方がよい
** エラーがMochaに届くようにエラーハンドリングは行わない