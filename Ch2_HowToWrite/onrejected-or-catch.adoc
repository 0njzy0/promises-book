== then or catch?

<<catch-as-alias,前の章>>で <<promise.catch,`.catch`>> は  `promise.then(undefined, onRejected)` であるという事を紹介しました。

この書籍では基本的には、<<promise.catch,`.catch`>>を使い <<promise.then,`.then`>> とは分けてエラーハンドリングを書くようにしています。

ここでは、<<promise.then,`.then`>> でまとめて指定した場合と、どのような違いがでるかについて学んでいきましょう。

=== エラー処理ができないonRejected

次のようなコードを見ていきます。

[source,js]
----
include::embed/embed-then-throw-error.js[]
----

このコード例では、(必ずしも悪いわけではないですが)良くないパターンの `badMain` と
ちゃんとエラーハンドリングが行える `goodMain` があります。

`badMain` がなぜ良くないかというと、<<promise.then,`.then`>> の第二引数にはエラー処理を書くことが出来ますが、
そのエラー処理は第一引数の`onFulfilled`で指定した関数内で起きたエラーをキャッチする事は出来ません。

つまり、この場合、 `theError` でエラーがおきても、`onRejected` に指定した関数は呼ばれることなく、
どこでエラーが発生したのかわからなくなってしまいます。

それに対して、 `goodMain` は `theError`->`onRejected`がchainするように書かれています。
この場合は `theError` でエラーが発生しても、次のchainである <<promise.catch,`.catch`>> が呼ばれるため、エラーハンドリングを行う事が出来ます。

<<promise.then,`.then`>> や <<promise.catch,`.catch`>> によるchainは、
一つ前のpromiseオブジェクトに対しての処理を行なわれるため、このような違いが生まれます。

[INFO]
====
`.then`や`.catch`はその場で**新しい**promiseオブジェクトを作って返します。
promiseでのchainは毎回異なるpromiseオブジェクトに対して処理を行っています。
====

[[then-catch-flow]]
.Then Catch flow
image::img/then_catch.png[Then Catch flow]

この図のようなchainになっている場合、`then`で発生した例外をキャッチ出来るのは、
次のchainで書かれた`catch`となります。

この場合の `then` は `Promise.resolve(42)` に対する処理となり、
その処理で指定された`onFulfilled`で例外が発生しても、同じthenで指定された`onRejected`はキャッチすることはありません。

そのため、`badMain`のような書き方をすると意図とは違ってエラーハンドリングができないケースが存在することは覚えておきましょう。
