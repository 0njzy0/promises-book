[[promise-sequence]]
== Promiseによる逐次処理

第2章の<<ch2-promise-all, Promise.all>>では、
複数のpromiseオブジェクトをまとめて処理する方法について学びました。

しかし、`Promise.all` は全ての処理を並行に行うため、
Aの処理 が終わったら Bの処理 というような逐次的な処理を扱うことが出来ません。

また、同じ2章の<<ch2-promise-and-array,Promiseと配列>>では、
効率的ではないですが、<<multiple-xhr.js,thenを連ねた書き方>>でそのような逐次処理を行っていました。

このセクションでは、Promiseを使った逐次処理の書き方について学んで行きたいと思います。

=== ループと逐次処理

<<multiple-xhr.js,thenを連ねた書き方>>では以下のような書き方でしたね。

[source,js]
----
include::../Ch2_HowToWrite/embed/embed-multiple-xhr.js[]
----

この書き方だと、`request`の数が増える分`then`でつながらないといけなくなるため、
ループなどを使って処理をまとめると数が増えた場合も問題無いですね。

[source,js]
[[promise-foreach-xhr.js]]
.promise-foreach-xhr.js
----
include::embed/embed-promise-foreach-xhr.js[]
----

forループで書く場合、<<then-return-new-promise,コラム: thenは常に新しいpromiseオブジェクトを返す
>>や<<promise-and-method-chain,Promiseとメソッドチェーン>>で学んだように、
<<promise.then.Promise#then>> は新しいpromiseオブジェクトを返しています。

そのため、`promise = promise.then(task).then(pushValue);`というのは`promise`という変数に
上書きするというよりは、そこに処理を追加したpromiseオブジェクトを更に作って行くというpromise chainが行われています。

しかし、この書き方だと一時変数として`promise`が必要で、処理の内容的もあまりスッキリしません。

このループの書き方は`Array.prototype.reduce`を使うともっとスマートに書くことが出来ます。

=== promise chainとreduce

`Array.prototype.reduce` を使って書き直すと以下のようになります。

[source,js]
[[promise-reduce-xhr.js]]
.promise-reduce-xhr.js
----
include::embed/embed-promise-reduce-xhr.js[]
----

`Array.prototype.reduce`は第二引数に初期値を入れることができるので、
一番最初に`promise`には`Promise.resolve()`が入ります。
そのときの`task`は`request.comment`となります。

reduceの中で`return`したものが次のループで`promise`に入ります。
つまり、`then`を使って作成した新たなpromiseオブジェクトを返していくと、forと同じようにループを回していくことが出来ます。

forループと異なる点は、一時変数としての`promise`が不要になることに伴い、
`promise = promise.then(task).then(pushValue);`という不格好な書き方がなくなる点が大きな違いだと思います。

`Array.prototype.reduce`とPromiseの逐次処理は相性が良いので覚えておくといいのですが、
初めて見た時にどういう動作をするのかがまだ分かりにくいという問題があります。

そこで、処理するTaskとなる関数の配列を受け取って逐次処理を行う
`sequenceTasks`というものを作ってみます。

以下のように書くことができれば、`tasks`が順番に処理されてく事が関数名から見てわかるようになります。

[source,js]
----
var tasks = [request.comment, request.people];
sequenceTasks(tasks);
----

=== 逐次処理を行う関数を定義する

基本的には、<<promise-reduce-xhr.js,reduceを使ったやり方>>を関数として切り離せればいいだけですね。

[source,js]
[[promise-sequence.js]]
.promise-sequence.js
----
include::embed/embed-promise-sequence.js[]
----

一つ注意点として、`Promise.all`等と違い、引数に受け取るのは関数の配列です。

何故promiseオブジェクトの配列ではないのかというのは、
この場合のpromiseオブジェクトの場合は作成段階で既にXHRが実行されている状態なので、
それを逐次処理しても、意図とは異なる動作になるためです。

そのため`sequenceTasks`では関数(promiseオブジェクトを返す)の配列を引数に受け取ります。

最後に、`sequenceTasks`を使って最初の例を書き換えると以下のようになります。

[source,js]
[[promise-sequence-xhr.js]]
.promise-sequence-xhr.js
----
include::embed/embed-promise-sequence-xhr.js[]
----


[source,js]
----
main().then(function (value) {
    console.log(value);
}).catch(function(error){
    console.log(error);
});
----

`main()`の中がかなりスッキリしたことが分かります。

このようにPromiseでは、逐次処理という事をするのに色々な書き方が出来てしまいます。

* <<multiple-xhr.js, thenをその場に並べた書き方>>
* <<promise-foreach-xhr.js, forループを使った書き方>>
* <<promise-reduce-xhr.js, reduceを使った書き方>>
* <<promise-sequence.js, 逐次処理する関数を分けた書き方>>

しかし、これはJavaScriptで配列を扱うのと本質的には余り違いはありません。
そのため、Promiseを扱う場合も処理をまとめられるところは小さく関数に分けて、
実装していくのがいいと言えるでしょう。

=== まとめ

このセクションでは、<<Promise.all, `Promise.all`>>とは違い、
一つづつ順番に処理を行っていくPromiseでの実装について学びました。

手続き的な書き方から、逐次処理を行う関数を定義するところまでを見ていき、
Promiseであっても関数に処理をわけるという基本的な事は変わらないことを示しました。

Promiseで書くとPromise chainを繋げすぎてしまい手続き的に書いてしまいがちです。

基本を振り返り処理を関数等にキチンと分けることで、全体の見通しを良くすることは大切です。

また、Promiseのコンストラクタ関数や`then`等は高階関数なので、
処理を関数に分けておくと組み合わせが行い易いという副次的な効果もありため、意識してみるといいかもしれません。

[NOTE]
高階関数とは引数に関数オブジェクトを受け取る関数のこと